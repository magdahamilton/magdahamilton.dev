<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WKDQQ1RDNT"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-WKDQQ1RDNT');
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solaris - Interactive WebGL Ocean Simulation | Magda Hamilton</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="An interactive simulation inspired by Stanisław Lem's Solaris. A sentient ocean driven by C++/WebAssembly viscoelastic physics, with real-time tidal force computation, observation-responsive behavior, and AI-driven mimoid formations. Built with Three.js, custom GLSL shaders, and Emscripten.">
    <meta name="keywords" content="Solaris, Stanisław Lem, C++, WebAssembly, viscoelastic simulation, WebGL, Three.js, ocean simulation, interactive art, creative technology, GLSL shaders, Magda Hamilton, three-body problem, Emscripten, real-time physics, creative coding, generative art">
    <meta name="author" content="Magda Hamilton">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://magdahamilton.dev/solaris.html">
    <meta property="og:title" content="Solaris - Interactive WebGL Ocean Simulation">
    <meta property="og:description" content="An interactive WebGL simulation inspired by Stanisław Lem's Solaris. A sentient ocean that responds to observation, stabilizes chaotic orbits, and generates alien formations.">
    <meta property="og:image" content="https://magdahamilton.dev/images/solaris-og.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Magda Hamilton">
    <meta property="article:author" content="Magda Hamilton">
    <meta property="article:published_time" content="2026-01-22">
    <meta property="article:modified_time" content="2026-01-27">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://magdahamilton.dev/solaris.html">
    <meta name="twitter:title" content="Solaris - Interactive WebGL Ocean Simulation">
    <meta name="twitter:description" content="An interactive WebGL simulation inspired by Stanisław Lem's Solaris. A sentient ocean that responds to observation and stabilizes chaotic orbits.">
    <meta name="twitter:image" content="https://magdahamilton.dev/images/solaris-og.jpg">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://magdahamilton.dev/solaris.html">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    
    <link rel="stylesheet" href="styles.css">
    
    <!-- Enhanced Schema.org markup -->
    <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "TechArticle",
      "@id": "https://magdahamilton.dev/solaris.html#article",
      "headline": "Solaris: Building an Interactive Simulation of Alien Consciousness",
      "description": "A technical deep-dive into building an interactive WebGL simulation inspired by Stanisław Lem's Solaris, featuring emergent formations, gravitational engineering, and observation-responsive behavior.",
      "image": "https://magdahamilton.dev/images/solaris-og.jpg",
      "datePublished": "2026-01-22",
      "dateModified": "2026-01-27",
      "author": {
        "@id": "https://magdahamilton.dev/#person"
      },
      "publisher": {
        "@id": "https://magdahamilton.dev/#person"
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://magdahamilton.dev/solaris.html"
      },
      "about": {
        "@id": "https://solaris.observer/#creativework"
      },
      "isBasedOn": {
        "@type": "Book",
        "name": "Solaris",
        "author": {
          "@type": "Person",
          "name": "Stanisław Lem"
        },
        "datePublished": "1961"
      },
      "keywords": "C++, WebAssembly, Emscripten, WebGL, Three.js, GLSL, viscoelastic simulation, interactive simulation, creative technology, three-body problem, generative art",
      "proficiencyLevel": "Expert",
      "dependencies": "Three.js, WebGL 2.0, GLSL ES 3.0, Emscripten (C++ to WebAssembly)",
      "inLanguage": "en"
    },
    {
      "@type": "WebApplication",
      "@id": "https://solaris.observer/#creativework",
      "name": "Solaris",
      "url": "https://solaris.observer",
      "description": "An interactive WebGL meditation on consciousness and the unknowable, inspired by Stanisław Lem's novel.",
      "applicationCategory": "Interactive Art",
      "operatingSystem": "Web Browser",
      "browserRequirements": "Requires WebGL support",
      "creator": {
        "@id": "https://magdahamilton.dev/#person"
      }
    },
    {
      "@id": "https://magdahamilton.dev/#person"
    }
  ]
}
    </script>
</head>
<body>
    <nav>
        <a href="index.html" class="back-link">← BACK TO PORTFOLIO</a>
        <div class="contact-icons">
            <a href="/cdn-cgi/l/email-protection#a9c1c0e9c4c8cecdc8c1c8c4c0c5ddc6c787cdccdf" aria-label="Email">
                <svg viewBox="0 0 24 24">
                    <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                </svg>
            </a>
            <a href="https://linkedin.com/in/magdahamilton" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
                <svg viewBox="0 0 24 24">
                    <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
                </svg>
            </a>
            <a href="https://github.com/magdahamilton" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
                <svg viewBox="0 0 24 24">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
            </a>
            <a href="https://www.are.na/magda-hamilton" target="_blank" rel="noopener noreferrer" aria-label="Are.na">
                <svg viewBox="0 0 150.38 88.9">
                    <path d="M148.93 62.356l-20.847-16.384c-1.276-1-1.276-2.642 0-3.645l20.848-16.38c1.28-1.002 1.815-2.695 1.19-3.76-.626-1.062-2.374-1.44-3.88-.84l-24.79 9.874c-1.507.606-2.927-.22-3.153-1.83L114.57 2.926C114.34 1.317 113.13 0 111.877 0c-1.247 0-2.456 1.317-2.68 2.925l-3.73 26.467c-.228 1.61-1.646 2.434-3.155 1.83l-24.38-9.71c-1.512-.602-3.975-.602-5.483 0l-24.384 9.71c-1.508.604-2.928-.22-3.154-1.83L41.186 2.925C40.956 1.317 39.748 0 38.5 0c-1.252 0-2.463 1.317-2.688 2.925l-3.73 26.467c-.226 1.61-1.645 2.434-3.153 1.83L4.14 21.35c-1.507-.603-3.252-.223-3.878.838-.625 1.066-.092 2.76 1.184 3.76l20.85 16.38c1.277 1.003 1.277 2.645 0 3.646L1.446 62.356C.166 63.358-.364 65.152.26 66.34c.627 1.19 2.372 1.668 3.877 1.064l24.567-9.866c1.51-.603 2.914.218 3.125 1.828l3.544 26.696c.214 1.607 1.618 2.923 3.12 2.923 1.5 0 2.905-1.315 3.12-2.923l3.55-26.696c.21-1.61 1.62-2.43 3.122-1.828l24.164 9.698c1.506.606 3.97.606 5.477 0l24.16-9.698c1.504-.603 2.91.218 3.125 1.828l3.55 26.696c.212 1.607 1.617 2.923 3.115 2.923 1.502 0 2.907-1.315 3.12-2.923l3.55-26.696c.216-1.61 1.62-2.43 3.124-1.828l24.57 9.866c1.5.604 3.25.125 3.876-1.063.627-1.186.094-2.98-1.185-3.982zM95.89 46.18L77.53 60.315c-1.285.99-3.393.99-4.674 0L54.49 46.18c-1.284-.99-1.294-2.62-.02-3.625l18.4-14.493c1.274-1.005 3.363-1.005 4.638 0l18.4 14.493c1.277 1.004 1.267 2.634-.02 3.626z"/>
                </svg>
            </a>
        </div>
    </nav>

    <div class="hero">
        <video class="hero-video" autoplay loop muted playsinline poster="images/solaris1.jpg">
            <source src="https://pub-9f205d406ae74fe29f7a63bd0a1e6df0.r2.dev/solaris_full.mp4" type="video/mp4">
        </video>
        <div class="hero-overlay">
            <div class="hero-title">
                <h1>Solaris</h1>
                <p class="tagline">An interactive meditation on consciousness and the unknowable</p>
            </div>
        </div>
    </div>

    <div class="content">
        <div class="project-meta">
            <div class="meta-item">
                <div class="meta-label">Role</div>
                <div class="meta-value">Concept, Design & Engineering</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">Year</div>
                <div class="meta-value">2026</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">Tech Stack</div>
                <div class="meta-value">C++, WebAssembly, Three.js, WebGL, GLSL</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">Published by</div>
                <div class="meta-value"><a href="https://velvetdisruption.com/lab/solaris.html" target="_blank" rel="noopener noreferrer">Velvet Disruption</a></div>
            </div>
        </div>

        <!-- CONCEPT SECTION -->
        <span class="section-marker">01 — Concept</span>
        <h2 id="concept">The Concept</h2>
        <p>
            In Stanisław Lem's 1961 novel <em>Solaris</em>, scientists discover a planet-sized ocean that thinks—but operates on logic so alien that despite decades of research, humans cannot communicate with it or understand its purpose. It generates elaborate structures, materializes visitors' deepest memories, and maintains a stable orbit around two suns through incomprehensible means.
        </p>
        <p>
            This project brings that entity to life: a living simulation driven by C++ physics running in WebAssembly. Beneath the visual surface, a Kelvin-Voigt viscoelastic solver models the ocean as sentient gel—not water—that stores stress, remembers past deformations, and actively shapes its own surface. The ocean responds to observation, but unpredictably. It creates formations that emerge and dissolve on their own timeline. It performs planetary-scale engineering that we can only glimpse through surface shimmer.
        </p>

        <p class="pull-quote">The ocean isn't performing for you—it simply exists, and you're privileged to witness its incomprehensible work.</p>

        <p>
            Most "alien" experiences in digital media are just exotic versions of familiar patterns. Solaris explores something harder: consciousness that operates on fundamentally different logic. The ocean isn't performing for you—it simply exists, and you're privileged to witness its incomprehensible work.
        </p>

        <!-- THREE-BODY PROBLEM SECTION -->
        <span class="section-marker">02 — Physics</span>
        <h2 id="three-body-problem">Solving the Three-Body Problem</h2>
        <p>
            One of the most fascinating aspects of Lem's novel: the planet orbits two suns—a configuration that should be gravitationally chaotic. In 1687, Newton formulated universal gravitation and could predict the motion of two celestial bodies perfectly. Then he tried to add a third body. The math disintegrated.
        </p>
        <p>
            For two centuries, mathematicians sought a general solution. Euler found specific stable configurations. Lagrange discovered five equilibrium points. Then in the 1880s, Henri Poincaré shattered the hope of a complete solution: he discovered that infinitesimally small changes in starting positions produced wildly different outcomes. The trajectories tangled into what he called "homoclinic tangles"—so complex they could never be captured by simple equations. Poincaré had discovered chaos itself.
        </p>
        <p>
            But Lem imagined something extraordinary: the ocean actively stabilizes its orbit through continuous mass redistribution. It doesn't solve the equations—it rewrites them constantly, treating the three-body problem not as a mathematical puzzle requiring an elegant solution, but as a control problem demanding constant intervention.
        </p>

        <!-- THREE-BODY DIAGRAM -->
        <div class="diagram-wrap">
            <div class="diagram-label">Fig. 01 — Three-Body Gravitational System</div>
            <canvas id="three-body-canvas" width="720" height="420"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background:#c0392b;"></div>
                    Red Giant (0.08 rad/s, r=250)
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#2980b9;"></div>
                    Blue Dwarf (0.12 rad/s, r=220)
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#2a2a2a;"></div>
                    Solaris (ocean stabilised)
                </div>
            </div>
        </div>

        <div class="version-section">
            <h3>Implementing Gravitational Chaos</h3>
            <p>I created two suns with fundamentally unstable orbits. The red giant moves slowly (0.08 rad/s) along a 250-unit radius orbit, while the blue dwarf races faster (0.12 rad/s) at 220 units. Their gravitational interference creates chaotic perturbations.</p>
            <p>But then the Ocean intervenes. Each frame, both sun positions feed into a C++ simulation running in WebAssembly. The solver computes tidal potential per cell across a 128×128 grid using the standard tidal force formula:</p>
            <pre><code>// C++ WASM — tidal force per cell
float tidal = (3.0f * dot * dot - 1.0f) * 0.5f * sun_tidal;

// The ocean counteracts 95% (gravitational engineering)
float leaked_force = total_tidal * 0.05f;
cell.velocity += leaked_force * dt;

// Counteraction effort generates stress
float counteraction_effort = fabsf(total_tidal) * 0.95f;
cell.stress += counteraction_effort * dt * 0.5f;</code></pre>
            <p>The stress is exported as a texture and visualized in the fragment shader—warm glow where the ocean is working hardest. This isn't a visual trick: the glow corresponds to actual computed gravitational counteraction happening in C++ 60 times per second.</p>
        </div>

        <div class="version-section">
            <h3>Visualizing the Engineering</h3>
            <p>The real challenge was making invisible work visible. In the fragment shader, I created "engineering zones" that appear where the Ocean is working hardest. When both suns align, pulsing patterns appear on the surface—FBM-based noise that simulates the Ocean's calculations made manifest:</p>
            <pre><code>float redEngineering = calculateEngineeringZone(uRedSunPos, uRedSunColor, 0);
float blueEngineering = calculateEngineeringZone(uBlueSunPos, uBlueSunColor, 1);</code></pre>
            <p>Where engineering zones overlap, they blend into purple—the Ocean simultaneously stabilizing against both gravitational pulls, its work visible in the interference pattern.</p>
        </div>

        <!-- OCEAN RENDERING SECTION -->
        <div class="media-break">
            <video autoplay loop muted playsinline poster="images/solaris1.jpg">
                <source src="https://pub-9f205d406ae74fe29f7a63bd0a1e6df0.r2.dev/solaris_full.mp4" type="video/mp4">
            </video>
            <span class="media-caption">The living surface — viscoelastic physics rendered in real time</span>
        </div>

        <span class="section-marker">03 — Rendering</span>
        <h2 id="ocean-surface">The Living Surface</h2>
        <p>
            The ocean's visual surface is driven by two systems working together. Custom vertex and fragment shaders handle the rendering—multi-layered wave displacement with Fractal Brownian Motion creates a surface that never repeats. But underneath, a C++/WebAssembly simulation computes the actual physics: a 128×128 grid of cells, each tracking height, velocity, stress, strain, viscosity, elasticity, intent, and memory.
        </p>

        <div class="version-section">
            <h3>Viscoelastic Physics (C++/WASM)</h3>
            <p>The ocean is modeled as a Kelvin-Voigt viscoelastic gel—not water. Water follows the wave equation (∂²h/∂t² = c²∇²h); gel follows a fundamentally different model where stress equals elastic strain plus viscous resistance. This matters because gel <em>resists</em> deformation, <em>stores</em> stress, and releases energy in wobbles rather than clean waves:</p>
            <pre><code>// C++ — Kelvin-Voigt viscoelastic solver
float elastic_force = -elasticity * (height - rest_position);
float viscous_force = -viscosity * velocity;
float neighbor_pull = (avg_neighbor_height - height) * stress_propagation;

velocity += (elastic_force + viscous_force + neighbor_pull) * dt;
velocity += intent * intent_responsiveness;  // The ocean CHOOSES
height += velocity * dt;
velocity *= damping;</code></pre>
            <p>The intent field is what makes this alien: each cell can actively push itself in a direction the ocean "wants" to go. The simulation also maintains memory—the rest position drifts based on past deformations, so the ocean never quite returns to the same shape.</p>
        </div>

        <div class="version-section">
            <h3>Mood-Driven Material Properties</h3>
            <p>The ocean's mood directly changes the physics. When agitated, viscosity drops and stress propagation increases—the gel becomes volatile and reactive. When aloof, viscosity rises dramatically—the ocean becomes sluggish, barely responding. When curious, elasticity peaks—the surface becomes springy and reaching. These aren't visual parameters; they're material properties in the C++ solver that change how the physics behaves.</p>
        </div>

        <!-- FORMATIONS SECTION -->
        <span class="section-marker">04 — Formations</span>
        <h2 id="formations">Emergent Formations</h2>
        <p>
            Five types of structures spawn spontaneously, each with a complete lifecycle—emergence, maturation, dissolution—weighted by rarity as described in Lem's novel:
        </p>

        <div class="version-section">
            <h3>Formation Types</h3>
            <p><strong>Symmetriads</strong> — Perfect radial symmetry, 6-12 arms, slow rotation. The most common formation.</p>
            <p><strong>Asymmetriads</strong> — Towering vertical structures, 50-100m height, irregular shapes that defy easy classification.</p>
            <p><strong>Mimoids</strong> — Undulating organic forms with fluid motion and membrane-like surfaces.</p>
            <p><strong>Vertebrids</strong> — Skeletal lattice structures with intricate internal geometry.</p>
            <p><strong>Extensors</strong> — The rarest formation. Sprawling horizontal networks with branch-like growth patterns.</p>
            <pre><code>const spawnWeights = {
    symmetriad: 0.35,    // Most common
    mimoid: 0.25,
    asymmetriad: 0.20,
    vertebrid: 0.12,
    extensor: 0.08       // Rarest
};</code></pre>
            <p>Each formation "breathes" through subtle internal motion, rendered with translucent shaders and flowing 3D noise patterns, suggesting processes we can only glimpse.</p>
        </div>

        <!-- OBSERVATION SECTION -->
        <span class="section-marker">05 — Observation</span>
        <h2 id="observation">Observation Response</h2>
        <p>
            The ocean notices when you're watching. Raycasting detects where the camera looks at the surface, and shader uniforms create localized "awareness" that spreads from observation points. Hover over the surface and it responds with rippling patterns and increased luminosity.
        </p>
        <p>
            But the behavior changes unpredictably every 15-30 seconds: sometimes curious, reaching toward your cursor; sometimes aloof, barely acknowledging you; occasionally recoiling, as if disturbed by observation. This unpredictability reflects Lem's concept—you're studying it, but it's also studying you.
        </p>

        <div class="version-section">
            <h3>How to Interact</h3>
            <p><strong>Movement:</strong> WASD or Arrow Keys. When close (< 8 units), walk on the surface. When far (> 8 units), orbit around the planet.</p>
            <p><strong>View:</strong> Mouse drag to look around.</p>
            <p><strong>Zoom:</strong> Mouse wheel, or Q/Space to zoom out, E/Shift to zoom in.</p>
            <p>Move your cursor slowly to see the Ocean "track" your movements with a delay. The longer you hover in one spot, the more intensely it responds.</p>
        </div>

        <!-- ATMOSPHERE SECTION -->
        <span class="section-marker">06 — Atmosphere</span>
        <h2 id="atmosphere">Atmospheric Effects</h2>
        <p>
            The simulation includes a multi-layered atmosphere: dynamic exponential fog that responds to sun position, shader-based surface mist with Simplex noise distortion, and periodic plasma eruptions—energy fountains with turbulent curl noise, temperature-based color gradients, and realistic particle physics.
        </p>
        <p>
            The starfield uses three depth layers with realistic stellar classification (O, B, A, F, G, K, M spectral types) and subtle parallax as the camera moves. Bioluminescence manifests as internal light orbs with pulsing shaders and electric discharge effects beneath the surface.
        </p>

        <!-- PERFORMANCE SECTION -->
        <span class="section-marker">07 — Performance</span>
        <h2 id="performance">Performance</h2>
        <p>
            The C++ viscoelastic simulation runs in ~1-2ms per frame for the full 128×128 grid (16,384 cells). Heightmap and stressmap are uploaded to the GPU as Float32Array views directly into WASM memory—zero-copy texture transfer. The rendering pipeline uses a three-tier LOD system that adjusts ocean surface complexity based on camera distance (128, 64, or 32 segments), instanced geometries for formations and plasma, and shader optimizations including varying caching and precision management.
        </p>
        <p>
            Results: consistent 60fps on high-end desktops at 1440p, 60fps on mid-range hardware at 1080p, and 30-60fps on modern mobile devices with automatic quality adjustment. The WASM simulation gracefully degrades—if it fails to load, the ocean falls back to shader-only rendering.
        </p>

        <!-- PHILOSOPHY SECTION -->
        <span class="section-marker">08 — Philosophy</span>
        <h2 id="philosophy">Design Philosophy</h2>
        <p>
            Unlike most interactive experiences, Solaris resists easy comprehension. There are no objectives, no progression systems, no explicit tutorials. The ocean operates on its own timeline. Formations emerge and dissolve without player input. This autonomy is crucial—you're not controlling anything, you're observing something that exists beyond your influence.
        </p>

        <p class="pull-quote">Not everything needs to be understood, explained, or mastered.</p>

        <p>
            Not everything needs to be understood, explained, or mastered. Sometimes the goal is simply to create a space where wonder can exist—where we can confront our own inability to comprehend the truly alien.
        </p>
        <p>
            The result is a simulation that captures what makes Lem's Ocean so unsettling: it doesn't communicate through language or symbols. It communicates through work—through the constant, tireless effort of keeping its world stable. Every glowing pattern on the surface, every pulsing engineering zone, every shimmer of residual chaos is the Ocean saying something we can observe but never fully understand.
        </p>

        <div class="tech-list">
            <span class="tech-tag">C++</span>
            <span class="tech-tag">WebAssembly</span>
            <span class="tech-tag">Emscripten</span>
            <span class="tech-tag">Three.js</span>
            <span class="tech-tag">WebGL 2.0</span>
            <span class="tech-tag">GLSL</span>
            <span class="tech-tag">Kelvin-Voigt Solver</span>
            <span class="tech-tag">Fractal Brownian Motion</span>
            <span class="tech-tag">Simplex Noise</span>
            <span class="tech-tag">Raycasting</span>
            <span class="tech-tag">Instanced Rendering</span>
        </div>

        <div class="cta">
            <a href="https://solaris.observer" target="_blank" rel="noopener noreferrer" class="btn">Experience Solaris</a>
        </div>
    </div>
    <footer>
        <p>© 2026 Magda Hamilton</p>
    </footer>

    <style>
        /* ===== THREE-BODY DIAGRAM ===== */
        .diagram-wrap {
            margin: 2.5rem 0 3rem;
        }
        .diagram-label {
            font-size: 0.65rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: #aaa;
            margin-bottom: 0.75rem;
        }
        #three-body-canvas {
            width: 100%;
            height: auto;
            display: block;
            border-top: 2px solid #2a2a2a;
            border-bottom: 1px solid #e0e0e0;
        }
        .legend {
            display: flex;
            gap: 2rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            letter-spacing: 1px;
            color: #666;
            text-transform: uppercase;
        }
        .legend-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            flex-shrink: 0;
        }
    </style>

    <script>
    (function() {
        const canvas = document.getElementById('three-body-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        const cx = W / 2, cy = H / 2;

        const RED  = { angle: 0,             speed: 0.0008, radius: W * 0.33, size: 9,   color: '#c0392b', trail: [] };
        const BLUE = { angle: Math.PI * 0.7, speed: 0.0014, radius: W * 0.29, size: 5.5, color: '#2980b9', trail: [] };
        const TRAIL = 280;
        const wobble = { x: 0, y: 0, vx: 0, vy: 0 };

        function drawTrail(trail, r, g, b) {
            for (let i = 1; i < trail.length; i++) {
                const a = (i / trail.length) * 0.18;
                ctx.beginPath();
                ctx.moveTo(trail[i-1].x, trail[i-1].y);
                ctx.lineTo(trail[i].x, trail[i].y);
                ctx.strokeStyle = `rgba(${r},${g},${b},${a})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        function drawSun(body, pos) {
            const g = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, body.size * 5);
            g.addColorStop(0, body.color + '55');
            g.addColorStop(1, 'transparent');
            ctx.beginPath(); ctx.arc(pos.x, pos.y, body.size * 5, 0, Math.PI*2);
            ctx.fillStyle = g; ctx.fill();
            ctx.beginPath(); ctx.arc(pos.x, pos.y, body.size, 0, Math.PI*2);
            ctx.fillStyle = body.color; ctx.fill();
        }

        function arrow(x1, y1, x2, y2, color) {
            const dx = x2-x1, dy = y2-y1, d = Math.sqrt(dx*dx+dy*dy);
            const nx = dx/d, ny = dy/d;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - nx*5 + (-ny)*3, y2 - ny*5 + nx*3);
            ctx.lineTo(x2 - nx*5 - (-ny)*3, y2 - ny*5 - nx*3);
            ctx.closePath(); ctx.fillStyle = color; ctx.fill();
        }

        function frame() {
            ctx.clearRect(0, 0, W, H);

            // Grid
            for (let x = 0; x < W; x += 40) {
                ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H);
                ctx.strokeStyle='rgba(42,42,42,0.04)'; ctx.lineWidth=1; ctx.stroke();
            }
            for (let y = 0; y < H; y += 40) {
                ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y);
                ctx.strokeStyle='rgba(42,42,42,0.04)'; ctx.lineWidth=1; ctx.stroke();
            }

            // Orbit rings
            ctx.save(); ctx.setLineDash([3,8]);
            ctx.beginPath(); ctx.arc(cx, cy, RED.radius, 0, Math.PI*2);
            ctx.strokeStyle='rgba(192,57,43,0.1)'; ctx.lineWidth=0.5; ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, cy, BLUE.radius, 0, Math.PI*2);
            ctx.strokeStyle='rgba(41,128,185,0.1)'; ctx.lineWidth=0.5; ctx.stroke();
            ctx.restore();

            RED.angle  += RED.speed;
            BLUE.angle += BLUE.speed;

            const rPos = { x: cx + Math.cos(RED.angle)  * RED.radius,  y: cy + Math.sin(RED.angle)  * RED.radius  * 0.38 };
            const bPos = { x: cx + Math.cos(BLUE.angle) * BLUE.radius, y: cy + Math.sin(BLUE.angle) * BLUE.radius * 0.38 };

            RED.trail.push({...rPos});  if (RED.trail.length  > TRAIL) RED.trail.shift();
            BLUE.trail.push({...bPos}); if (BLUE.trail.length > TRAIL) BLUE.trail.shift();

            drawTrail(RED.trail,  192, 57,  43);
            drawTrail(BLUE.trail, 41,  128, 185);
            drawSun(RED,  rPos);
            drawSun(BLUE, bPos);

            // Perturbation → planet wobble (ocean damps 95%)
            const forces = [rPos, bPos].map(p => {
                const dx = p.x - cx, dy = p.y - cy, d2 = dx*dx + dy*dy;
                return { fx: (dx/d2)*800, fy: (dy/d2)*800 };
            });
            const totalFx = forces[0].fx + forces[1].fx;
            const totalFy = forces[0].fy + forces[1].fy;
            wobble.vx = (wobble.vx + totalFx * 0.05 * 0.002) * 0.92;
            wobble.vy = (wobble.vy + totalFy * 0.05 * 0.002) * 0.92;
            wobble.x  = (wobble.x + wobble.vx) * 0.97;
            wobble.y  = (wobble.y + wobble.vy) * 0.97;

            const stress = Math.min(Math.sqrt(totalFx*totalFx + totalFy*totalFy) / 60, 1);
            const px = cx + wobble.x, py = cy + wobble.y;

            // Stress glow
            if (stress > 0.01) {
                const sg = ctx.createRadialGradient(px, py, 0, px, py, 45);
                sg.addColorStop(0, `rgba(180,120,60,${stress * 0.45})`);
                sg.addColorStop(1, 'transparent');
                ctx.beginPath(); ctx.arc(px, py, 45, 0, Math.PI*2);
                ctx.fillStyle = sg; ctx.fill();
            }

            // Planet
            ctx.beginPath(); ctx.arc(px, py, 13, 0, Math.PI*2);
            ctx.fillStyle = '#2a2a2a'; ctx.fill();
            ctx.font = '9px Courier New';
            ctx.fillStyle = 'rgba(42,42,42,0.45)';
            ctx.fillText('SOLARIS', px + 18, py + 3);

            // Force arrows
            [
                { pos: rPos, color: 'rgba(192,57,43,0.28)' },
                { pos: bPos, color: 'rgba(41,128,185,0.28)' }
            ].forEach(({ pos, color }) => {
                const dx = px - pos.x, dy = py - pos.y, d = Math.sqrt(dx*dx+dy*dy);
                const mid = 0.45;
                arrow(
                    pos.x + dx*mid - (dx/d)*14, pos.y + dy*mid - (dy/d)*14,
                    pos.x + dx*mid + (dx/d)*14, pos.y + dy*mid + (dy/d)*14,
                    color
                );
            });

            // Stress readout
            ctx.font = '8px Courier New';
            ctx.fillStyle = 'rgba(42,42,42,0.35)';
            ctx.fillText(`ocean stress: ${(stress*100).toFixed(0)}%`,  12, H - 24);
            ctx.fillText(`counteraction: ${(stress*95).toFixed(0)}%`, 12, H - 12);

            requestAnimationFrame(frame);
        }
        frame();
    })();
    </script>
</body>
</html>
