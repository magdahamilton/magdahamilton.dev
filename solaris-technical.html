<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solaris - Technical Documentation - Magda Hamilton</title>
    <meta name="description" content="Technical deep dive into the WebGL implementation of Solaris: shader architecture, ocean simulation, formation systems, and performance optimization.">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <a href="solaris.html" class="back-link">← BACK TO PROJECT</a>
        <div class="contact-icons">
            <a href="/cdn-cgi/l/email-protection#4028210025292f2c29202924202538212064292835" aria-label="Email">
                <svg viewBox="0 0 24 24">
                    <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                </svg>
            </a>
            <a href="https://linkedin.com/in/magdahamilton" target="_blank" aria-label="LinkedIn">
                <svg viewBox="0 0 24 24">
                    <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
                </svg>
            </a>
            <a href="https://github.com/magdhamilt" target="_blank" aria-label="GitHub">
                <svg viewBox="0 0 24 24">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
            </a>
        </div>
    </nav>

    <div class="content">
        <h1>Solaris: Technical Documentation</h1>
        <p class="subtitle">A deep dive into the WebGL implementation of an alien ocean consciousness</p>

        <nav class="toc">
            <h3>Table of Contents</h3>
            <ul>
                <li><a href="#architecture">System Architecture</a></li>
                <li><a href="#ocean-rendering">Ocean Surface Rendering</a></li>
                <li><a href="#formations">Formation Lifecycle System</a></li>
                <li><a href="#observation">Observation Response Mechanics</a></li>
                <li><a href="#three-body">Three-Body Problem Implementation</a></li>
                <li><a href="#atmosphere">Atmospheric Effects</a></li>
                <li><a href="#performance">Performance Optimization</a></li>
                <li><a href="#challenges">Technical Challenges</a></li>
            </ul>
        </nav>

        <h2 id="architecture">System Architecture</h2>
        
        <div class="version-section">
            <h3>Tech Stack</h3>
            <ul>
                <li><strong>Three.js r128</strong> - 3D rendering framework</li>
                <li><strong>WebGL 2.0</strong> - GPU-accelerated graphics</li>
                <li><strong>GLSL ES 3.0</strong> - Custom vertex and fragment shaders</li>
                <li><strong>Vanilla JavaScript</strong> - No additional frameworks</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Core Components</h3>
            <p>The simulation is built on a modular architecture with clear separation of concerns:</p>
            <ul>
                <li><strong>OceanSurface</strong> - Main ocean geometry with dynamic shader materials</li>
                <li><strong>FormationManager</strong> - Spawning, lifecycle, and dissolution of structures</li>
                <li><strong>ObservationSystem</strong> - Raycasting and response behavior</li>
                <li><strong>GravitationalEngine</strong> - Dual-sun orbital mechanics simulation</li>
                <li><strong>AtmosphereRenderer</strong> - Fog, mist, stars, and environmental effects</li>
                <li><strong>PerformanceManager</strong> - LOD system and frame rate optimization</li>
            </ul>
        </div>

        <h2 id="ocean-rendering">Ocean Surface Rendering</h2>

        <div class="version-section">
            <h3>Vertex Displacement</h3>
            <p>The ocean surface uses multi-layered sinusoidal wave displacement combined with Fractal Brownian Motion (FBM) to create organic, non-repeating motion:</p>
            <pre><code>// Simplified vertex shader pseudocode
vec3 displacement = vec3(0.0);

// Multi-frequency wave layers
for (int i = 0; i < 3; i++) {
    float freq = 3.0 + float(i) * 2.0;  // 3.0, 5.0, 7.0 Hz
    float amp = 1.0 / (float(i) + 1.0);
    displacement.y += sin(position.x * freq + time) * amp;
    displacement.y += cos(position.z * freq + time * 0.8) * amp;
}

// Add Fractal Brownian Motion for organic variation
displacement.y += fbm(position.xz * 0.1 + time * 0.05) * 2.0;

newPosition = position + displacement;</code></pre>
        </div>

        <div class="version-section">
            <h3>Dynamic Viscosity</h3>
            <p>Procedural noise controls viscosity variations across the surface, affecting visual properties:</p>
            <ul>
                <li><strong>High viscosity regions</strong> (gel-like) - Lower transparency, higher reflectivity, slower wave motion</li>
                <li><strong>Low viscosity regions</strong> (liquid) - Higher transparency, subsurface scattering, faster motion</li>
                <li><strong>Transition zones</strong> - Smooth gradients using Perlin noise</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Fragment Shader Effects</h3>
            <p>The fragment shader implements several key visual effects:</p>
            <ul>
                <li><strong>Subsurface Scattering</strong> - Light penetrates deeper in liquid regions, with exponential attenuation based on depth</li>
                <li><strong>Fresnel Effect</strong> - Edge glow that intensifies in more liquid regions, simulating light refraction at the surface</li>
                <li><strong>Bioluminescence</strong> - Animated glow patterns beneath the surface using 3D Simplex noise</li>
                <li><strong>Specular Highlights</strong> - Dynamic reflection of dual suns with Phong shading model</li>
            </ul>
        </div>

        <h2 id="formations">Formation Lifecycle System</h2>

        <div class="version-section">
            <h3>Formation Types</h3>
            <p>Five distinct formation types, each with unique geometry and behavior patterns:</p>
            <ul>
                <li><strong>Symmetriads</strong> - Perfect radial symmetry, 6-12 arms, slow rotation</li>
                <li><strong>Asymmetriads</strong> - Towering vertical structures, 50-100m height, irregular shapes</li>
                <li><strong>Mimoids</strong> - Undulating organic forms, fluid motion, membrane-like surfaces</li>
                <li><strong>Vertebrids</strong> - Skeletal lattice structures, intricate internal geometry</li>
                <li><strong>Extensors</strong> - Sprawling horizontal networks, branch-like growth patterns</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Spawning System</h3>
            <p>Formations spawn using weighted probability distribution that mirrors Lem's descriptions of rarity:</p>
            <pre><code>// Formation spawn weights
const spawnWeights = {
    symmetriad: 0.35,    // Most common
    mimoid: 0.25,
    asymmetriad: 0.20,
    vertebrid: 0.12,
    extensor: 0.08       // Rarest
};

// Spawn check runs every 30-120 seconds
function attemptSpawn() {
    if (activeFormations.length >= MAX_FORMATIONS) return;
    
    const roll = Math.random();
    let cumulative = 0;
    
    for (const [type, weight] of Object.entries(spawnWeights)) {
        cumulative += weight;
        if (roll <= cumulative) {
            spawnFormation(type);
            break;
        }
    }
}</code></pre>
        </div>

        <div class="version-section">
            <h3>Lifecycle Phases</h3>
            <p>Each formation progresses through distinct phases:</p>
            <ol>
                <li><strong>Emergence (2-5 minutes)</strong> - Rises from ocean surface, geometry unfolds, opacity increases</li>
                <li><strong>Maturation (5-15 minutes)</strong> - Reaches full size, stable form, internal patterns flow</li>
                <li><strong>Dissolution (3-8 minutes)</strong> - Structure breaks down, sinks back into ocean, fragments disperse</li>
            </ol>
            <p>Internal patterns are generated using 3D Simplex noise flowing through time, making each formation visually unique despite using the same base geometry.</p>
        </div>

        <h2 id="observation">Observation Response Mechanics</h2>

        <div class="version-section">
            <h3>Raycasting System</h3>
            <p>Continuous raycasting from camera to ocean surface detects observation points:</p>
            <pre><code>function detectObservation() {
    raycaster.setFromCamera(mousePosition, camera);
    const intersects = raycaster.intersectObject(oceanSurface);
    
    if (intersects.length > 0) {
        const point = intersects[0].point;
        const duration = Date.now() - observationStartTime;
        
        // Intensity increases with observation duration
        const intensity = Math.min(duration / 5000, 1.0);
        
        triggerResponse(point, intensity);
    }
}</code></pre>
        </div>

        <div class="version-section">
            <h3>Response Behaviors</h3>
            <p>The ocean cycles through different behavioral states every 15-30 seconds:</p>
            <ul>
                <li><strong>Curious (40% probability)</strong> - Ripples move toward observation point, increased luminescence, subtle reaching motion</li>
                <li><strong>Aloof (35% probability)</strong> - Minimal response, brief acknowledgment then returns to baseline</li>
                <li><strong>Recoiling (15% probability)</strong> - Ripples move away from point, decreased opacity in area, avoidance behavior</li>
                <li><strong>Tracking (10% probability)</strong> - Follows cursor movement with delay, as if processing through alien senses</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Shader-Based Awareness</h3>
            <p>Response effects are implemented in shaders for performance:</p>
            <pre><code>// Fragment shader receives observation points as uniforms
uniform vec3 observationPoints[MAX_OBSERVATIONS];
uniform float observationIntensities[MAX_OBSERVATIONS];
uniform float observationTimes[MAX_OBSERVATIONS];

// Calculate distance-based influence
float awareness = 0.0;
for (int i = 0; i < activeObservations; i++) {
    float dist = distance(worldPosition.xz, observationPoints[i].xz);
    float falloff = 1.0 - smoothstep(0.0, 20.0, dist);
    float decay = exp(-observationTimes[i] * 0.5);  // Fades over time
    awareness += observationIntensities[i] * falloff * decay;
}

// Modulate bioluminescence and surface properties
luminosity += awareness * 2.0;
rippleAmplitude += awareness * 0.5;</code></pre>
        </div>

        <h2 id="three-body">Three-Body Problem Implementation</h2>

        <div class="version-section">
            <h3>Orbital Mechanics</h3>
            <p>The dual-sun system creates gravitational chaos through the three-body problem. The simulation calculates forces from both suns on the planet:</p>
            <pre><code>function calculateGravitationalForces() {
    // Sun positions orbit each other
    const sun1Pos = getSunPosition(1, time);
    const sun2Pos = getSunPosition(2, time);
    
    // Calculate forces on planet from each sun
    const force1 = gravitationalForce(planetPos, sun1Pos, SUN_1_MASS);
    const force2 = gravitationalForce(planetPos, sun2Pos, SUN_2_MASS);
    
    // Total chaotic force
    const chaoticForce = force1.add(force2);
    
    return chaoticForce;
}</code></pre>
        </div>

        <div class="version-section">
            <h3>Ocean Countermeasures</h3>
            <p>The ocean actively counteracts 95% of gravitational instability through mass redistribution:</p>
            <ul>
                <li><strong>Engineering zones</strong> - Grid-based regions that shift mass in real-time</li>
                <li><strong>Shimmer patterns</strong> - Visible evidence of mass redistribution work</li>
                <li><strong>Interference effects</strong> - When suns align, shimmer intensifies showing increased effort</li>
                <li><strong>Residual chaos</strong> - The remaining 5% creates organic motion patterns</li>
            </ul>
            <p>This is rendered as animated displacement patterns that pulse with the orbital period of the suns.</p>
        </div>

        <h2 id="atmosphere">Atmospheric Effects</h2>

        <div class="version-section">
            <h3>Fog & Mist</h3>
            <ul>
                <li><strong>Exponential fog</strong> - Distance-based atmospheric scattering that responds to sun position</li>
                <li><strong>Shader-based mist</strong> - 3D Simplex noise creates volumetric mist layers that drift over time</li>
                <li><strong>Light scattering</strong> - God rays when suns are at low angles</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Starfield</h3>
            <p>Three-layer starfield system with astronomical accuracy:</p>
            <ul>
                <li><strong>Background stars</strong> - Dense field of dim stars using point sprites</li>
                <li><strong>Mid-layer stars</strong> - Medium brightness with color variation (spectral classes)</li>
                <li><strong>Foreground stars</strong> - Brightest stars with subtle twinkling effect</li>
                <li><strong>Parallax</strong> - Layers move at different rates with camera rotation</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Plasma Eruptions</h3>
            <p>Energy fountains that erupt across the surface:</p>
            <ul>
                <li>Spawned randomly with varying intensity and duration</li>
                <li>Particle systems with turbulent flow using curl noise</li>
                <li>Temperature-based color gradients (blue → white → orange)</li>
                <li>Upward acceleration with drag and fade over lifetime</li>
            </ul>
        </div>

        <h2 id="performance">Performance Optimization</h2>

        <div class="version-section">
            <h3>Level of Detail (LOD) System</h3>
            <p>Three-tier LOD automatically adjusts ocean surface complexity:</p>
            <pre><code>const LOD_LEVELS = {
    HIGH: { segments: 128, distance: 50 },
    MEDIUM: { segments: 64, distance: 150 },
    LOW: { segments: 32, distance: Infinity }
};

function updateLOD() {
    const distance = camera.position.distanceTo(oceanCenter);
    
    for (const [level, config] of Object.entries(LOD_LEVELS)) {
        if (distance < config.distance) {
            oceanGeometry.setSegments(config.segments);
            break;
        }
    }
}</code></pre>
        </div>

        <div class="version-section">
            <h3>Instanced Rendering</h3>
            <p>Formations and plasma fountains use instanced geometries to minimize draw calls:</p>
            <ul>
                <li>Single geometry with instance-specific transform matrices</li>
                <li>Shader attributes for per-instance colors, scales, rotations</li>
                <li>Reduces draw calls from hundreds to single-digit counts</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Shader Optimization</h3>
            <ul>
                <li><strong>Varying caching</strong> - Complex calculations done in vertex shader, passed to fragment shader</li>
                <li><strong>Uniform updates</strong> - Only update changed uniforms, not entire material</li>
                <li><strong>Precision optimization</strong> - Use mediump where highp isn't required</li>
                <li><strong>Early exit</strong> - Fragment shader discards unnecessary calculations</li>
            </ul>
        </div>

        <div class="version-section">
            <h3>Results</h3>
            <p>Performance metrics across device categories:</p>
            <ul>
                <li><strong>High-end desktop</strong> (RTX 3080) - Consistent 60fps at 1440p</li>
                <li><strong>Mid-range desktop</strong> (GTX 1060) - 60fps at 1080p with medium LOD</li>
                <li><strong>Mobile</strong> (iPhone 12+, Galaxy S21+) - 30-60fps with automatic LOD adjustment</li>
            </ul>
        </div>

        <h2 id="challenges">Technical Challenges & Solutions</h2>

        <div class="version-section">
            <h3>Challenge: Non-Repeating Organic Motion</h3>
            <p><strong>Problem:</strong> Simple wave equations create obvious repeating patterns that break the illusion of alien consciousness.</p>
            <p><strong>Solution:</strong> Combined multiple noise functions (Perlin, Simplex, FBM) at different frequencies and octaves. Added time-based phase shifts that are never quite synchronized, creating complex emergent patterns.</p>
        </div>

        <div class="version-section">
            <h3>Challenge: Maintaining Mystery</h3>
            <p><strong>Problem:</strong> Predictable responses make the ocean feel like a simple interactive system rather than unknowable intelligence.</p>
            <p><strong>Solution:</strong> Implemented behavioral state machine that randomly switches modes. Added delayed responses, partial responses, and occasional non-responses to create uncertainty about what the ocean "wants" or "understands".</p>
        </div>

        <div class="version-section">
            <h3>Challenge: Mobile Performance</h3>
            <p><strong>Problem:</strong> Complex shaders and geometry were unplayable on mobile devices.</p>
            <p><strong>Solution:</strong> Aggressive LOD system, simplified shaders for mobile (fewer noise octaves, reduced precision), reduced particle counts, and frame rate-based dynamic adjustment of visual quality.</p>
        </div>

        <div class="version-section">
            <h3>Challenge: Convincing Three-Body Physics</h3>
            <p><strong>Problem:</strong> Actually simulating chaotic three-body orbits is computationally expensive and visually confusing.</p>
            <p><strong>Solution:</strong> Simulated the chaos mathematically but had the ocean counteract most of it. Show only the 5% "leak" as shimmer patterns. This creates the impression of vast invisible work without overwhelming the viewer.</p>
        </div>

        <h2>Future Improvements</h2>
        <ul>
            <li><strong>VR Support</strong> - Immersive experience would amplify the sense of scale</li>
            <li><strong>Sound Design</strong> - Procedural audio that responds to formation activity and observation</li>
            <li><strong>Formation Communication</strong> - Subtle interactions between nearby formations</li>
            <li><strong>Memory Manifestations</strong> - Implement Lem's concept of materialized visitors from memory</li>
            <li><strong>WebGPU Port</strong> - Leverage next-gen graphics API for enhanced visuals</li>
        </ul>

        <div class="cta">
            <a href="https://solaris.observer" target="_blank" class="btn">Experience Solaris</a>
            <a href="solaris.html" class="btn btn-secondary">Back to Project Overview</a>
        </div>
    </div>

    <footer>
        <p>© 2026 Magda Hamilton</p>
    </footer>
</body>
</html>
